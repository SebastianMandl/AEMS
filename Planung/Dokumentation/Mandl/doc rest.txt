3 HTTP Methods: POST, PUT, DELETE ...
... werden benutzt


POST:
	o JQuery
	o + andere Packets (Login, ...)

	o Bsp.:

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "QUERY"
		data: {
			meters {
				id
				user {
					id,
					username
				}
			}
		}
	}

PUT:
	o INSERT und UPDATE
	o ob es ein INSERT oder ein UPDATE ist wird mit dem Attribut action gesteuert
	o eingehendes JSON muss sich auf EIN SQL-STM auflösen (FLAT)

	o Bsp.: 

	{ id:"AT...3333", meters : [{user:185}, {user:190}]}

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "INSERT",
		data: {
			meters : [
				{
					# ein Meter-Objekt
					user : 185,
					id : "AT0000000000000000000000003333",
					city : "Linz",
					...
				}
			]
		}
	}	


	o Oben gezeigtes Beispiel ist eine INSERT-Operation welche in die Tabelle "Meters" einfügt,
	o dabei darf das JSON-"Meters" Objekt keine weiteren Subobjekte beinhalten (FLAT).

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "UPDATE",
		data: {
			meters : [
				{
					# ein Meter-Objekt
					user : 185,
					city : "Linz",
					...
				}
			],
			id : "AT0000000000000000000000003333"
		}
	}

	o Oben gezeigtes Beispiel ist im Prinzip das Gleiche wie das Vorhergehende, ist jedoch eine UPDATE-Operation,
	o dabei spielt die Zeile ... id : "AT0000000000000000000000003333" ... eine wichtige Rolle. Diese ist die WHERE-Klausel.
	o Dies bedeutet, dass nur jenes Objekt geupdated wird, bei welchem die Spalte "id" auch den Wert "AT0000000000000000000000003333" besitzt.
	o Anmerkung: Die Spalte muss nicht "id" heißen. Der Propertyname entspricht dem Spaltennamen in der Datenbank!!!

-------------------------------------------------------------------------------------------------------------------------------------------------



Verschlüsselung für Android mit AES:

Im Git-Repository ist ein Projekt mit dem Namen AEMSUtilLib vorzufinden.
In dieser Library sind zwei signifikante Klassen für die Ver- und Entschlüsselung enthalten:

	o at.htlgkr.aems.util.crypto.Encrypter
	o at.htlgkr.aems.util.crypto.Decrypter

Benutzt werden oben gennante Klassen wie folgt:

	# public static byte[] requestEncryption(byte[] key, byte[] raw)

	encryptedBytes = Encrypter.requestEncryption(key, rawBytes)

	# public static byte[] requestDecryption(byte[] key, byte[] encrypted)

	rawBytes = Decrypter.requestDecryption(key, encryptedBytes)

Wie oben zu erkennen ist, benötigen beide Funktionen für die Operation einen "Key".
Dieser ist der AES-Key (16 bytes):

Damit man ein gemeinsamen Schlüssel mit dem gegenüber (Server) aufbaut, muss dieser auf sicherer
Art und Weise auf beiden Seiten berechnet und gesaltet werden.

Die dafür benötigte Funktionalität ist in der Klasse at.htlgkr.aems.util.key.DiffieHellmanProcedure eingebunden.

		# Die nachfolgende Zeile initiiert den Schlüsselaustausch.
		# Mit dieser Zeile wird ein Teil des Schlüssels berechnet und an das Gegenüber gesendet.

		byte[] clientKey;
		# Port 9950 ist obligatorisch
		# Die IP-Adresse ist die des Servers
		DiffieHellmanProcedure.sendKeyInfos(new Socket(InetAddress.getByName("127.0.0.1"), 9950));
		
		# Muss in einem Thread ausgeführt werden, da die Schlüsselberechnung längere Zeit dauern kann,
		# sonst würde die UI freezen!!!
		new Thread(() -> {
			try {
				# Diese Zeile schließt den Schlüsselaustausch ab.
				# Nachdem die Funktion den Schlüssel returniert hat, kann
				# man davon ausgehen, das sowohl Server als auch Client den gleichen Schlüssel besitzen.
				clientKey = DiffieHellmanProcedure.confirmKey();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}).start();
		
		while(clientKey == null);
		
		# KeyUtils.salt(...) multipliziert die Hashwerte von %username% und %password% in den ausgetauschten Schlüssel hinein.
		BigDecimal definitiveKey = KeyUtils.salt(new BigDecimal(new String(clientKey)), "username", "password");
		# in "definitiveKey" ist nun der entgültige Schlüssel vorzufinden.
		...

		String text = "test";
		byte[] encrypted = Encrypter.requestEncryption(definitiveKey, text.getBytes());

		byte[] raw = Decrypter.requestDecryption(definitiveKey, encrypted);

		String msg = new String(raw);
		...

---------------------------------------------------------------------------------------------------------------------------------------------------

Encoding von dem Parameter "data":
	o Base64 (Java ... Base64.getUrlEncoder() oder Base64.getUrlDecoder())

Actions:
	o INSERT
	o UPDATE
	o DELETE
	o QUERY
	o LOGIN

Parameter für AES:
	o encryption
	o user #id oder username
	o data
	o action

Parameter für SSL:
	o encryption
	o user #id oder username
	o data
	o action
	o auth_str # sha256(username + password)

Anmerkung SSL:
	Der Parameter "user" ist entweder die Id oder der Username -> mit dieser Information werden aus der Datenbank die "richtigen" Benutzerdaten
	geholt, welche dann gehasht werden sha256(username + password) und anschließend mit dem vom Client gesendendeten "auth_str" verglichen werden.
	Stimmen diese überein wird von einer positiven Anmeldung ausgegangen.

Anmerkung AES:
	Bei AES Verschlüsselung ist der "auth_str" nicht notwendig, da die Daten mit dem gesalteten AES-Key aus Random-Key * hash(username) * hash(password) an den
	Server versendet werden. Der Server kann die Daten nur entschlüsseln (und somit ausführen), wenn die angegebenen Benutzerdaten jenen in der Datenbank entsprechen.
	Dannach werden die Daten mit den Benutzerdaten aus der Datenbank verschlüsselt und zurück an den Client gesendet. Nur jener, welcher den Random-Teil des Schlüssels,
	Benutzername und Passwort kennt, kann die Daten auch wieder entschlüsseln aus verwerten.