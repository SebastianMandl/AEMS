3 HTTP Methods: POST, PUT, DELETE ...
... werden benutzt


POST:
	o JQuery
	o + andere Packets (Login, ...)

	o Bsp.:

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "QUERY"
		data: {
			meters {
				id
				user {
					id,
					username
				}
			}
		}
	}

PUT:
	o INSERT und UPDATE
	o ob es ein INSERT oder ein UPDATE ist wird mit dem Attribut action gesteuert
	o eingehendes JSON muss sich auf EIN SQL-STM auflösen (FLAT)

	o Bsp.: 

	{ id:"AT...3333", meters : [{user:185}, {user:190}]}

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "INSERT",
		data: {
			meters : [
				{
					# ein Meter-Objekt
					user : 185,
					id : "AT0000000000000000000000003333",
					city : "Linz",
					...
				}
			]
		}
	}	


	o Oben gezeigtes Beispiel ist eine INSERT-Operation welche in die Tabelle "Meters" einfügt,
	o dabei darf das JSON-"Meters" Objekt keine weiteren Subobjekte beinhalten (FLAT).

	{
		user_id : 185,
		auth_str : "39A16CC6B7D7943C1F75A6DFA14385E06CC06CA12233FE806BBACC5175173A23B642CD63EC1936B4C65080689BD74A21C00C0524896FF8AAAF069E5B5FB6EC7E",
		action : "UPDATE",
		data: {
			meters : [
				{
					# ein Meter-Objekt
					user : 185,
					city : "Linz",
					...
				}
			],
			id : "AT0000000000000000000000003333"
		}
	}

	o Oben gezeigtes Beispiel ist im Prinzip das Gleiche wie das Vorhergehende, ist jedoch eine UPDATE-Operation,
	o dabei spielt die Zeile ... id : "AT0000000000000000000000003333" ... eine wichtige Rolle. Diese ist die WHERE-Klausel.
	o Dies bedeutet, dass nur jenes Objekt geupdated wird, bei welchem die Spalte "id" auch den Wert "AT0000000000000000000000003333" besitzt.
	o Anmerkung: Die Spalte muss nicht "id" heißen. Der Propertyname entspricht dem Spaltennamen in der Datenbank!!!

-------------------------------------------------------------------------------------------------------------------------------------------------



Verschlüsselung für Android mit AES:

Im Git-Repository ist ein Projekt mit dem Namen AEMSUtilLib vorzufinden.
In dieser Library sind zwei signifikante Klassen für die Ver- und Entschlüsselung enthalten:

	o at.htlgkr.aems.util.crypto.Encrypter
	o at.htlgkr.aems.util.crypto.Decrypter

Benutzt werden oben gennante Klassen wie folgt:

	# public static byte[] requestEncryption(byte[] key, byte[] raw)

	encryptedBytes = Encrypter.requestEncryption(key, rawBytes)

	# public static byte[] requestDecryption(byte[] key, byte[] encrypted)

	rawBytes = Decrypter.requestDecryption(key, encryptedBytes)

Wie oben zu erkennen ist, benötigen beide Funktionen für die Operation einen "Key".
Dieser ist der AES-Key (16 bytes):

Damit man ein gemeinsamen Schlüssel mit dem gegenüber (Server) aufbaut, muss dieser auf sicherer
Art und Weise auf beiden Seiten berechnet und gesaltet werden.

Die dafür benötigte Funktionalität ist in der Klasse at.htlgkr.aems.util.key.DiffieHellmanProcedure eingebunden.

		# Die nachfolgende Zeile initiiert den Schlüsselaustausch.
		# Mit dieser Zeile wird ein Teil des Schlüssels berechnet und an das Gegenüber gesendet.

		byte[] clientKey;
		# Port 9950 ist obligatorisch
		# Die IP-Adresse ist die des Servers
		DiffieHellmanProcedure.sendKeyInfos(new Socket(InetAddress.getByName("127.0.0.1"), 9950));
		
		# Muss in einem Thread ausgeführt werden, da die Schlüsselberechnung längere Zeit dauern kann,
		# sonst würde die UI freezen!!!
		new Thread(() -> {
			try {
				# Diese Zeile schließt den Schlüsselaustausch ab.
				# Nachdem die Funktion den Schlüssel returniert hat, kann
				# man davon ausgehen, das sowohl Server als auch Client den gleichen Schlüssel besitzen.
				clientKey = DiffieHellmanProcedure.confirmKey();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}).start();
		
		while(clientKey == null);
		
		# KeyUtils.salt(...) multipliziert die Hashwerte von %username% und %password% in den ausgetauschten Schlüssel hinein.
		BigDecimal definitiveKey = KeyUtils.salt(new BigDecimal(new String(clientKey)), "username", "password");
		# in "definitiveKey" ist nun der entgültige Schlüssel vorzufinden.
		...

		String text = "test";
		byte[] encrypted = Encrypter.requestEncryption(definitiveKey, text.getBytes());

		byte[] raw = Decrypter.requestDecryption(definitiveKey, encrypted);

		String msg = new String(raw);
		...

