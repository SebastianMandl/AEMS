-- run this setup script as the database administrator
-- this script is required to be run within an existing database

DROP OWNED BY aems CASCADE; -- everything which has been owned by the user "aems" will be dropped by issuing this command
DROP USER IF EXISTS aems;
CREATE USER aems WITH ENCRYPTED PASSWORD 'aems' VALID UNTIL '2018-01-01' ; -- creates the user with a predifined password. This password is required to be changed for security reasons!

GRANT CONNECT ON DATABASE "AEMSData" TO aems; -- grants the user to connect to the database

DROP SCHEMA IF EXISTS aems; -- in case if the schema already existed (e.g. this script has run before) drop it
CREATE SCHEMA aems AUTHORIZATION aems; -- create the schema "aems" and authorizes it to the user "aems". (clear text: the schema "aems" belongs to the user "aems")

-- setting up the table with their belonging constraints
DROP TABLE IF EXISTS aems."MeterTypes" CASCADE;
CREATE TABLE aems."MeterTypes"
(
  id numeric(10,0) NOT NULL,
  displayname character varying(100) NOT NULL,
  CONSTRAINT pk_metertypes PRIMARY KEY (id)
)

DROP TABLE IF EXISTS aems."Users" CASCADE;
CREATE TABLE aems."Users"
(
  id numeric(10,0) NOT NULL,
  username character varying(32) NOT NULL,
  password character varying(4096) NOT NULL,
  CONSTRAINT pk_users PRIMARY KEY (id),
  CONSTRAINT users_username_key UNIQUE (username)
)

DROP TABLE IF EXISTS aems."Meters" CASCADE;
CREATE TABLE aems."Meters"
(
  id character varying(150) NOT NULL,
  metertype numeric(10,0),
  "user" numeric(10,0),
  city character varying(50),
  latitude numeric(10,10),
  longitude numeric(10,10),
  CONSTRAINT pk_meters PRIMARY KEY (id),
  CONSTRAINT fk_meters_metertypes FOREIGN KEY (metertype)
      REFERENCES aems."MeterTypes" (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_meters_users FOREIGN KEY ("user")
      REFERENCES aems."Users" (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)

DROP TABLE IF EXISTS aems."MeterData" CASCADE;
CREATE TABLE aems."MeterData"
(
  id numeric(10,0) NOT NULL,
  meter character varying(150),
  "timestamp" timestamp without time zone NOT NULL,
  measuredvalue numeric(7,5) NOT NULL,
  CONSTRAINT pk_meterdata PRIMARY KEY (id),
  CONSTRAINT fk_meterdata_meters FOREIGN KEY (meter)
      REFERENCES aems."Meters" (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)

DROP TABLE IF EXISTS aems."WeatherData" CASCADE;
CREATE TABLE aems."WeatherData"
(
  id numeric(10,0) NOT NULL,
  meter character varying(150) NOT NULL,
  "timestamp" timestamp without time zone,
  temperature numeric(2,2),
  humidity numeric(3,2),
  CONSTRAINT pk_weatherdata PRIMARY KEY (id),
  CONSTRAINT fk_weatherdata_meters FOREIGN KEY (meter)
      REFERENCES aems."Meters" (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)

-- setting up all the functions

DROP FUNCTION aems.delete_user(varchar);
CREATE OR REPLACE FUNCTION aems.delete_user(p_username character varying) RETURNS boolean AS $$
declare

	row_count_before integer;
	row_count_after integer;

begin
	
	select count(*) into row_count_before
	from aems."Users";

	delete from aems."Users"
	where username = p_username;

	select count(*) into row_count_after
	from aems."Users";

	if row_count_before > row_count_after then
		return true;
	else
		return false;
	end if;
end;
$$ LANGUAGE plpgsql;

DROP FUNCTION aems.get_user_password(varchar);
CREATE OR REPLACE FUNCTION aems.get_user_password(p_username character varying) RETURNS character varying AS $$
declare
	pass_bytes bytea;
	decrypted_password_bytes bytea;
	aes_key varchar(48);
	aes_key_bytes bytea;
	user_password_bytes bytea;

	datafile text default 'key.txt';
begin
	-- aquire the key from the key file ; preliminarily located within the data directory at serverside
	-- key file must be relocated in the future!!!
	aes_key := pg_read_file(datafile, 0, 48);

	select "password" into user_password_bytes
	from aems."Users"
	where username = p_username;

	aes_key_bytes := convert_to(aes_key, 'UTF-8');
	decrypted_password_bytes := decrypt(user_password_bytes, aes_key_bytes, 'aes');

	return convert_from(decrypted_password_bytes, 'UTF-8');

exception
	when others then
		return null;	-- will occur if the username is not valid
end;
$$ LANGUAGE plpgsql;

DROP FUNCTION aems.register_user(varchar, varchar);
CREATE OR REPLACE FUNCTION aems.register_user(username character varying, clear_text_password character varying) RETURNS boolean AS $$
declare
	pass_bytes bytea;
	decrypted_text varchar(4096);
	encrypted_pass_bytes bytea;
	aes_key varchar(48);
	aes_key_bytes bytea;

	datafile text default 'key.txt';

	row_count_before integer;
	row_count_after integer;
begin
	-- aquire the key from the key file ; preliminarily located within the data directory at serverside
	-- key file must be relocated in the future!!!
	aes_key := pg_read_file(datafile, 0, 48);

	pass_bytes := convert_to(clear_text_password, 'UTF-8');
	aes_key_bytes := convert_to(aes_key, 'UTF-8');
	encrypted_pass_bytes := encrypt(pass_bytes, aes_key_bytes, 'aes');

	select count(*) into row_count_before
	from aems."Users";

	insert into aems."Users" (id, username, "password")
	values (nextval('aems.user_seq'), username, encrypted_pass_bytes);

	select count(*) into row_count_after
	from aems."Users";

	if row_count_before < row_count_after then
		return true;
	else
		return false;
	end if;

exception
	when others then
		return false;	
end;
$$ LANGUAGE plpgsql;

-- setting up sequences

CREATE SEQUENCE aems.user_seq
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 15
  CACHE 5;

-- finishing permission setup


-- the following sets up the select permission on all the various tables within the schema "aems"
GRANT SELECT ON TABLE aems."Users" TO aems;
GRANT SELECT ON TABLE aems."Meters" TO aems;
GRANT SELECT ON TABLE aems."MeterData" TO aems;
GRANT SELECT ON TABLE aems."MeterTypes" TO aems;
GRANT SELECT ON TABLE aems."WeatherData" TO aems;

GRANT INSERT ON TABLE aems."Users" TO aems;
GRANT INSERT ON TABLE aems."Meters" TO aems;
GRANT INSERT ON TABLE aems."MeterData" TO aems;
GRANT INSERT ON TABLE aems."MeterTypes" TO aems;
GRANT INSERT ON TABLE aems."WeatherData" TO aems;

GRANT UPDATE ON TABLE aems."Users" TO aems;
GRANT UPDATE ON TABLE aems."Meters" TO aems;
GRANT UPDATE ON TABLE aems."MeterData" TO aems;
GRANT UPDATE ON TABLE aems."MeterTypes" TO aems;
GRANT UPDATE ON TABLE aems."WeatherData" TO aems;

GRANT DELETE ON TABLE aems."Users" TO aems;
GRANT DELETE ON TABLE aems."Meters" TO aems;
GRANT DELETE ON TABLE aems."MeterData" TO aems;
GRANT DELETE ON TABLE aems."MeterTypes" TO aems;
GRANT DELETE ON TABLE aems."WeatherData" TO aems;

-- grant the user "aems" to execute the required functions for proper operation
GRANT EXECUTE ON FUNCTION aems.delete_user(varchar) TO aems;
GRANT EXECUTE ON FUNCTION aems.get_user_password(varchar) TO aems;
GRANT EXECUTE ON FUNCTION aems.register_user(varchar, varchar) TO aems;

-- revoking all the privileges from others that do not need accessibility
-- REVOKE ALL PRIVILEGES ON DATABASE "AEMSData" FROM public;
REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA aems FROM postgres;
REVOKE ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA aems FROM postgres;
REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA aems FROM postgres;


ALTER TABLE aems."Users" OWNER TO aems;
ALTER TABLE aems."MeterData" OWNER TO aems;
ALTER TABLE aems."Meters" OWNER TO aems;
ALTER TABLE aems."MeterTypes" OWNER TO aems;
ALTER TABLE aems."WeatherData" OWNER TO aems;

ALTER FUNCTION aems.get_user_password(varchar) OWNER TO aems;
ALTER FUNCTION aems.register_user(varchar, varchar) OWNER TO aems;
ALTER FUNCTION aems.delete_user(varchar) OWNER TO aems;

ALTER SEQUENCE aems.user_seq OWNER TO aems;
